% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/app-driver.R
\name{AppDriver}
\alias{AppDriver}
\title{Remote control a Shiny app running in a headless browser}
\description{
This class starts a Shiny app in a new R session, along with a \pkg{chromote}
headless browser that can be used to simulate user actions. This provides
a full simulation of a Shiny app so that you can test user interactions
with a live app.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{AppDriver$new()}}
\item \href{#method-view}{\code{AppDriver$view()}}
\item \href{#method-expect_appshot}{\code{AppDriver$expect_appshot()}}
\item \href{#method-expect_text}{\code{AppDriver$expect_text()}}
\item \href{#method-expect_html}{\code{AppDriver$expect_html()}}
\item \href{#method-expect_script}{\code{AppDriver$expect_script()}}
\item \href{#method-expect_download}{\code{AppDriver$expect_download()}}
\item \href{#method-get_values}{\code{AppDriver$get_values()}}
\item \href{#method-get_names}{\code{AppDriver$get_names()}}
\item \href{#method-set_inputs}{\code{AppDriver$set_inputs()}}
\item \href{#method-click}{\code{AppDriver$click()}}
\item \href{#method-upload_file}{\code{AppDriver$upload_file()}}
\item \href{#method-wait_for_condition}{\code{AppDriver$wait_for_condition()}}
\item \href{#method-wait_for_idle}{\code{AppDriver$wait_for_idle()}}
\item \href{#method-wait_for_value}{\code{AppDriver$wait_for_value()}}
\item \href{#method-execute_script}{\code{AppDriver$execute_script()}}
\item \href{#method-execute_script_callback}{\code{AppDriver$execute_script_callback()}}
\item \href{#method-get_path}{\code{AppDriver$get_path()}}
\item \href{#method-get_url}{\code{AppDriver$get_url()}}
\item \href{#method-get_window_size}{\code{AppDriver$get_window_size()}}
\item \href{#method-set_window_size}{\code{AppDriver$set_window_size()}}
\item \href{#method-get_chromote_session}{\code{AppDriver$get_chromote_session()}}
\item \href{#method-get_debug_log}{\code{AppDriver$get_debug_log()}}
\item \href{#method-enable_debug_log_messages}{\code{AppDriver$enable_debug_log_messages()}}
\item \href{#method-get_event_log}{\code{AppDriver$get_event_log()}}
\item \href{#method-log_event}{\code{AppDriver$log_event()}}
\item \href{#method-stop}{\code{AppDriver$stop()}}
\item \href{#method-clone}{\code{AppDriver$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize the AppDriver
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$new(
  path = testthat::test_path("../../"),
  ...,
  load_timeout = NULL,
  screenshot_args = NULL,
  check_names = TRUE,
  name = NULL,
  variant = getOption("shinytest2.variant", platform_variant()),
  debug = c("none", "all", debug_types()),
  view = FALSE,
  seed = NULL,
  clean_logs = TRUE,
  shiny_args = list(),
  render_args = NULL,
  options = list()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{path}}{Path to a directory containing a Shiny app, i.e. a
single \code{app.R} file or a \code{server.R}-\code{ui.R} pair.}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{load_timeout}}{How long to wait for the app to load, in ms.
This includes the time to start R. Defaults to 5s when running
locally and 10s when running on CI. Maximum value is 10s.}

\item{\code{screenshot_args}}{Default set of arguments to pass in to \code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}'s
\verb{$screenshot()} method when taking screnshots within \verb{$expect_appshot()}. To disable screenshots by default, set to \code{FALSE}.}

\item{\code{check_names}}{Check if widget names are unique?}

\item{\code{name}}{Prefix name to use when saving testthat snapshot files}

\item{\code{variant}}{If not-\code{NULL}, results will be saved in
_snaps/{variant}/{test.md}\verb{, so }variant` must be a single
string of alphanumeric characters suitable for use as a
directory name.

You can variants to deal with cases where the snapshot output
varies and you want to capture and test the variations.
Common use cases include variations for operating system, R
version, or version of key dependency.}

\item{\code{debug}}{Start the app in debugging mode? In debugging mode debug
messages are printed to the console. See \code{\link[=debug_types]{debug_types()}} for more information.}

\item{\code{view}}{Opens the Chromote Session  in an interactive browser tab once initialization.}

\item{\code{seed}}{An optional random seed to use before starting the application.
For apps that use R's random number generator, this can make their
behavior repeatable.}

\item{\code{clean_logs}}{Whether to remove the stdout and stderr logs when the
Shiny process object is garbage collected.}

\item{\code{shiny_args}}{A list of options to pass to \code{\link[shiny:runApp]{shiny::runApp()}}.}

\item{\code{render_args}}{Passed to \code{rmarkdown::run()} for interactive \code{.Rmd}s.}

\item{\code{options}}{A list of \code{\link[base:options]{base::options()}} to set in the driver's child
process.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-view"></a>}}
\if{latex}{\out{\hypertarget{method-view}{}}}
\subsection{Method \code{view()}}{
Calls \verb{$view()} on the Chromote Session object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$view()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_appshot"></a>}}
\if{latex}{\out{\hypertarget{method-expect_appshot}{}}}
\subsection{Method \code{expect_appshot()}}{
Take and appshot of the Shiny application

Appshot: Shiny \strong{App}lication Snap\strong{shot}

An appshot currently consists of two snapshot files:
\enumerate{
\item A screenshot of the Shiny application using the \verb{$screenshot()} function of the \code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}
\item A JSON snapshot of all Shiny component values
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_appshot(
  ...,
  items = NULL,
  screenshot = NULL,
  name = NULL,
  cran = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{items}}{Components to only be included in the snapshot. If supplied, can contain \code{inputs}, \code{output}, and \code{export}. Each value of \code{items} can either be \code{TRUE} (for all values) or a character list of names to use.}

\item{\code{screenshot}}{If the value is \code{NULL}, then the initalization value of \code{screenshot_args} will be used. If this value is \code{NULL}, then \code{screenshot} will be set to the result of \code{!is.null(items)}.

The final value can either be:
\itemize{
\item \code{TRUE}: A screenshot of the whole page will be taken with no delay
\item \code{FALSE}: No screenshot will be taken
\item A named list of arguments: Arguments passed directly to \code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}'s
\verb{$screenshot()} method. The selector and delay will default to \code{"html"} and \code{0} respectively.
}}

\item{\code{name}}{The prefix name to be used for the snapshot. By default, this uses the name supplied to \code{app} on initialization.}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_text"></a>}}
\if{latex}{\out{\hypertarget{method-expect_text}{}}}
\subsection{Method \code{expect_text()}}{
Expect snapshot of UI text

\verb{$expect_text()} will extract the text value of all matching elements via \code{TAG.textContent} and store them in a snapshot file.
This method is more robust to internal package change as only the text values will be maintained.

When possible, use \verb{$expect_text()} over \verb{$expect_html()} to allow package authors room to alter their HTML structures.
The resulting array of \code{TAG.textContent} values found will be stored in a snapshot file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_text(selector, ..., cran = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{selector}}{A DOM CSS selector to be passed into \code{document.querySelectorAll()}}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_html"></a>}}
\if{latex}{\out{\hypertarget{method-expect_html}{}}}
\subsection{Method \code{expect_html()}}{
Expect snapshot of UI HTML

\verb{$expect_html()} will extract the full DOM structures of each matching element and store them in a snapshot file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_html(selector, ..., outer_html = FALSE, cran = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{selector}}{A DOM selector to be passed into \code{document.querySelectorAll()}}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{outer_html}}{If \code{TRUE}, the full DOM structure will be returned (\code{TAG.outerHTML}).
If \code{FALSE}, the full DOM structure of the child elements will be returned (\code{TAG.innerHTML}).}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_script"></a>}}
\if{latex}{\out{\hypertarget{method-expect_script}{}}}
\subsection{Method \code{expect_script()}}{
Expect snapshot of JS script output

This is a building block function that should be called by other functions.
For example, \verb{$expect_text()} and \verb{$expect_html()} are thin wrappers around this function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_script(
  script,
  arguments = list(),
  ...,
  timeout = 15 * 1000,
  pre_snapshot = NULL,
  cran = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{script}}{A string containing the JS script to be executed.}

\item{\code{arguments}}{A list of unnamed arguments to send to the script.}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{timeout}}{Amount of time to wait before giving up (milliseconds).}

\item{\code{pre_snapshot}}{A function to be called on the result of the script before taking the snapshot.
\verb{$expect_html()} and \verb{$expect_text()} both use \code{\link[=unlist]{unlist()}}.}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_download"></a>}}
\if{latex}{\out{\hypertarget{method-expect_download}{}}}
\subsection{Method \code{expect_download()}}{
Expect a download file action.

Given a \code{\link[shiny:downloadButton]{shiny::downloadButton()}}/\code{\link[shiny:downloadButton]{shiny::downloadLink()}} \code{id}, the corresponding
file will be downloaded and saved as a snapshot file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_download(id, ..., name = NULL, cran = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{Output id of \code{\link[shiny:downloadButton]{shiny::downloadButton()}}/\code{\link[shiny:downloadButton]{shiny::downloadLink()}}}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{name}}{File name to save file to. The default, \code{NULL},
generates an ascending sequence of names: \verb{001.download},
\verb{002.download}, etc.}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_values"></a>}}
\if{latex}{\out{\hypertarget{method-get_values}{}}}
\subsection{Method \code{get_values()}}{
Returns a named list of all inputs, outputs, and export values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_values(input = TRUE, output = TRUE, export = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{input, output, export}}{Either \code{TRUE} to return all
input/output/exported values, or a character vector of specific
controls.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_names"></a>}}
\if{latex}{\out{\hypertarget{method-get_names}{}}}
\subsection{Method \code{get_names()}}{
Returns a set of names for of all inputs, outputs, and exports
that Shiny is currently aware of.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_names(input = TRUE, output = TRUE, export = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{input, output, export}}{Either \code{TRUE} to return all
input/output/exported values, or \code{FALSE} to return no names.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_inputs"></a>}}
\if{latex}{\out{\hypertarget{method-set_inputs}{}}}
\subsection{Method \code{set_inputs()}}{
Set input values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$set_inputs(
  ...,
  wait_ = TRUE,
  values_ = TRUE,
  timeout_ = 3 * 1000,
  allow_input_no_binding_ = FALSE,
  priority_ = c("input", "event")
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Name-value pairs, \verb{component_name_1 = value_1, component_name_2 = value_2} etc.
Input with name \code{component_name_1} will be assigned value \code{value_1}.}

\item{\code{wait_}}{Wait until all reactive updates have completed?}

\item{\code{values_}}{If \code{TRUE}, will return final updated values of inputs.}

\item{\code{timeout_}}{Amount of time to wait before giving up (milliseconds).}

\item{\code{allow_input_no_binding_}}{When setting the value of an input, allow
it to set the value of an input even if that input does not have
an input binding.}

\item{\code{priority_}}{Sets the event priority. For expert use only: see
\url{https://shiny.rstudio.com/articles/communicating-with-js.html#values-vs-events} for details.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns updated values, invisibly.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-click"></a>}}
\if{latex}{\out{\hypertarget{method-click}{}}}
\subsection{Method \code{click()}}{
Find a Shiny binding and click it using the DOM method \code{TAG.click()}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$click(id, iotype = c("auto", "input", "output"))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The HTML ID of the element to click}

\item{\code{iotype}}{Type of the Shiny component. \pkg{shinytest2} is able to find
the component by their name, so this is only needed if you use the same name
for an input and output component.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-upload_file"></a>}}
\if{latex}{\out{\hypertarget{method-upload_file}{}}}
\subsection{Method \code{upload_file()}}{
Uploads a file to a file input.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$upload_file(..., wait_ = TRUE, values_ = TRUE, timeout_ = 3 * 1000)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Name-path pair, e.g. \code{component_name = file_path}. The file located at
\code{file_path} will be uploaded to file input with name \code{component_name}.}

\item{\code{wait_}}{Wait until all reactive updates have completed?}

\item{\code{values_}}{If \code{TRUE}, will return final updated values of download
control. Otherwise, the return value will be \code{NULL}.}

\item{\code{timeout_}}{Amount of time to wait before giving up (milliseconds).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-wait_for_condition"></a>}}
\if{latex}{\out{\hypertarget{method-wait_for_condition}{}}}
\subsection{Method \code{wait_for_condition()}}{
Wait for a JavaScript expression to be true

Waits until a JavaScript \code{expr}ession evaluates to \code{true} or the
\code{timeout} is exceeded.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$wait_for_condition(expr, timeout = 3 * 1000, interval = 100)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{A string containing JavaScript code. Will wait until the
condition returns \code{true}.}

\item{\code{timeout}}{How often to check for the condition, in ms.}

\item{\code{interval}}{How often to check for the condition, in ms.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{TRUE} if expression evaluates to \code{true} without error, before
timeout. Otherwise returns \code{FALSE}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-wait_for_idle"></a>}}
\if{latex}{\out{\hypertarget{method-wait_for_idle}{}}}
\subsection{Method \code{wait_for_idle()}}{
Wait for Shiny to not be busy

Waits until Shiny is not busy, i.e. the reactive graph has finished
updating. This is useful, for example, if you've resized the window with
\verb{$set_window_size()} and want to make sure all plot redrawing is complete
before take a screenshot.

While this function may return true, Shiny may not have fully stablized.
It is best to use \verb{TODO-barret-implement wait for stable}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$wait_for_idle(timeout = 3 * 1000, interval = 100)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{timeout}}{How often to check for the condition, in ms.}

\item{\code{interval}}{How often to check for the condition, in ms.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{TRUE} if done before before timeout; \code{NA} otherwise.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-wait_for_value"></a>}}
\if{latex}{\out{\hypertarget{method-wait_for_value}{}}}
\subsection{Method \code{wait_for_value()}}{
Wait for a new Shiny value

Waits until the \code{input} or \code{output} with name \code{name} is not one of
\code{ignore}d values, or the timeout is reached.

This function can be useful in helping determine if an application
has initialized or finished processing a complex reactive situation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$wait_for_value(
  id,
  ignore = list(NULL, ""),
  iotype = c("input", "output", "export"),
  timeout = 10 * 1000,
  interval = 400
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{Name of the Shiny binding}

\item{\code{ignore}}{List of possible values to ignore when checking for
updates.}

\item{\code{iotype}}{Type of the Shiny component. \pkg{shinytest2} is able to find
the component by their name, so this is only needed if you use the same name
for an input and output component.}

\item{\code{timeout}}{How often to check for the condition, in ms.}

\item{\code{interval}}{How often to check for the condition, in ms.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Newly found value
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-execute_script"></a>}}
\if{latex}{\out{\hypertarget{method-execute_script}{}}}
\subsection{Method \code{execute_script()}}{
Execute JavaScript code in the browser.

This function will block the local R session until the code has finished executing its \emph{tick} in the browser.
If a \code{Promise} is returned from the script, \verb{$execute_script()} will wait for the promise to resolve.
To have JavaScript code execute asynchronously, wrap the code in a Promise object and have the script return an atomic value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$execute_script(script, arguments = list(), ..., timeout = 15 * 1000)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{script}}{JS to execute. If a JS Promise is returned, \verb{$execute_script()} will wait for the promise to resolve before returning.}

\item{\code{arguments}}{A list of unnamed arguments to send to the script.}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{timeout}}{Amount of time to wait before giving up (milliseconds).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Result of the script.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-execute_script_callback"></a>}}
\if{latex}{\out{\hypertarget{method-execute_script_callback}{}}}
\subsection{Method \code{execute_script_callback()}}{
Execute JavaScript code in the browser with an additional \code{resolve} and \code{reject} arguments.

This function will block the local R session until one of the last two arguments (\code{resolve} and \code{reject}) are called.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$execute_script_callback(
  script,
  arguments = list(),
  ...,
  timeout = 15 * 1000
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{script}}{JS to execute. \code{resolve} and \code{reject} arguments are added to the script call. To return control back to the R session, one of these methods must be called.}

\item{\code{arguments}}{A list of unnamed arguments to send to the script.}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{timeout}}{Amount of time to wait before giving up (milliseconds).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Self, invisibly.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_path"></a>}}
\if{latex}{\out{\hypertarget{method-get_path}{}}}
\subsection{Method \code{get_path()}}{
Retrieve the Shiny app path
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_path()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
If it's a .Rmd file, it will return the full .Rmd path, otherwise it will return the directory containing the file.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_url"></a>}}
\if{latex}{\out{\hypertarget{method-get_url}{}}}
\subsection{Method \code{get_url()}}{
Retrieve the Shiny app URL
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_url()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
URL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_window_size"></a>}}
\if{latex}{\out{\hypertarget{method-get_window_size}{}}}
\subsection{Method \code{get_window_size()}}{
Get current size of the browser window, as list of integer scalars
named \code{width} and \code{height}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_window_size()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_window_size"></a>}}
\if{latex}{\out{\hypertarget{method-set_window_size}{}}}
\subsection{Method \code{set_window_size()}}{
Sets size of the browser window.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$set_window_size(width, height)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{width, height}}{Height and width of browser, in pixels.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_chromote_session"></a>}}
\if{latex}{\out{\hypertarget{method-get_chromote_session}{}}}
\subsection{Method \code{get_chromote_session()}}{
Chromote Session object from the \pkg{chromote} package.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_chromote_session()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_debug_log"></a>}}
\if{latex}{\out{\hypertarget{method-get_debug_log}{}}}
\subsection{Method \code{get_debug_log()}}{
Query one or more of the debug logs.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_debug_log(type = c("all", debug_types()))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{Log type: \code{"all"}, \code{"shiny_console"}, \code{"browser"},
or \code{"shinytest2"}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-enable_debug_log_messages"></a>}}
\if{latex}{\out{\hypertarget{method-enable_debug_log_messages}{}}}
\subsection{Method \code{enable_debug_log_messages()}}{
Enable/disable debugging messages
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$enable_debug_log_messages(enable = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{enable}}{If \code{TRUE}, all Shiny WebSocket messages are recorded.
This can be useful for debugging, but can be considered a memory leak in the browser.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_event_log"></a>}}
\if{latex}{\out{\hypertarget{method-get_event_log}{}}}
\subsection{Method \code{get_event_log()}}{
Retrieve event log.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_event_log()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-log_event"></a>}}
\if{latex}{\out{\hypertarget{method-log_event}{}}}
\subsection{Method \code{log_event()}}{
Add an event to log.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$log_event(event, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{event}}{Event name}

\item{\code{...}}{Addition data to store for event}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-stop"></a>}}
\if{latex}{\out{\hypertarget{method-stop}{}}}
\subsection{Method \code{stop()}}{
Stop the Shiny application
Stop the app, the terminate external R process that runs the app and
the Chromote Session instance.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$stop()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
