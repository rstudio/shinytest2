% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/app-driver.R
\name{AppDriver}
\alias{AppDriver}
\title{Remote control a Shiny app running in a headless browser}
\description{
This class starts a Shiny app in a new R session, along with a \pkg{chromote}
headless browser that can be used to simulate user actions. This provides
a full simulation of a Shiny app so that you can test user interactions
with a live app.
}
\section{Startup failure}{


If the app throws an error during initialization, the AppDriver will
will be stored in \code{rlang::last_error()$app}. This allows for the "failure
to initialize" to be signaled while also allowing for the \code{app} to be
retrieved after any initialization error has been thrown.
}

\examples{

## ------------------------------------------------
## Method `AppDriver$expect_unique_names`
## ------------------------------------------------

example_app <- system.file("tests/testthat/apps/init-input/", package = "shinytest2")
# Initial checking for unique names (default behavior)
\dontrun{app <- AppDriver$new(example_app, check_names = TRUE)}
# Manually assert that all names are unique
\dontrun{app <- AppDriver$new(example_app, check_names = FALSE)
app$expect_unique_names()}

## ------------------------------------------------
## Method `AppDriver$get_log`
## ------------------------------------------------

\dontrun{

app <- AppDriver$new(system.file("examples/01_hello", package = "shiny"))
app$get_log()
# \{shinytest2\} R  info  11:15:20.11 Start AppDriver initialization
# \{shinytest2\} R  info  11:15:20.11 Starting Shiny app
# \{shinytest2\} R  info  11:15:20.99 Creating new chromote session
# \{shinytest2\} R  info  11:15:21.14 Navigating to Shiny app
# \{shinytest2\} R  info  11:15:21.27 Injecting shiny-tracer.js
# \{chromote\}   JS info  11:15:21.28 shinytest2; jQuery not found
# \{chromote\}   JS info  11:15:21.28 shinytest2; Loaded
# \{shinytest2\} R  info  11:15:21.28 Waiting until Shiny app starts
# \{chromote\}   JS info  11:15:21.35 shinytest2; jQuery found
# \{chromote\}   JS info  11:15:21.35 shinytest2; Waiting for shiny session to connect
# \{chromote\}   JS info  11:15:21.57 shinytest2; Connected
# \{chromote\}   JS info  11:15:21.57 shinytest2; Ready
# \{chromote\}   JS info  11:15:21.65 shinytest2; shiny:busy
# \{shinytest2\} R  info  11:15:21.65 Shiny app started
# \{chromote\}   JS info  11:15:21.88 shinytest2; shiny:idle
# \{chromote\}   JS info  11:15:21.88 shinytest2; shiny:value distPlot
# \{shiny\}      R  error ----------- Loading required package: shiny
# \{shiny\}      R  error ----------- Running application in test mode.
# \{shiny\}      R  error -----------
# \{shiny\}      R  error ----------- Listening on http://127.0.0.1:42558


# To capture all websocket traffic, set `options = list(shiny.trace = TRUE)`
app <- AppDriver$new(
  system.file("examples/01_hello", package = "shiny"),
  options = list(shiny.trace = TRUE)
)
app$get_log() # (long output lines have been truncated)
# \{shinytest2\} R  info      11:09:57.43 Start AppDriver initialization
# \{shinytest2\} R  info      11:09:57.43 Starting Shiny app
# \{shinytest2\} R  info      11:09:58.27 Creating new chromote session
# \{shinytest2\} R  info      11:09:58.40 Navigating to Shiny app
# \{shinytest2\} R  info      11:09:58.53 Injecting shiny-tracer.js
# \{chromote\}   JS info      11:09:58.53 shinytest2; jQuery not found
# \{chromote\}   JS info      11:09:58.53 shinytest2; Loaded
# \{shinytest2\} R  info      11:09:58.54 Waiting until Shiny app starts
# \{chromote\}   JS info      11:09:58.61 shinytest2; jQuery found
# \{chromote\}   JS info      11:09:58.61 shinytest2; Waiting for shiny session to connect
# \{chromote\}   JS websocket 11:09:58.73 send \{"method":"init","data":\{"bins":30,|truncated
# \{chromote\}   JS websocket 11:09:58.78 recv \{"config":\{"workerId":"","sessionId":|truncated
# \{chromote\}   JS info      11:09:58.78 shinytest2; Connected
# \{chromote\}   JS info      11:09:58.78 shinytest2; Ready
# \{chromote\}   JS websocket 11:09:58.85 recv \{"custom":\{"showcase-src":\{"srcref":|truncated
# \{chromote\}   JS websocket 11:09:58.85 recv \{"busy":"busy"\}
# \{chromote\}   JS info      11:09:58.85 shinytest2; shiny:busy
# \{chromote\}   JS websocket 11:09:58.86 recv \{"custom":\{"showcase-src":\{"srcref":|truncated
# \{chromote\}   JS websocket 11:09:58.86 recv \{"recalculating":\{"name":"distPlot",|truncated
# \{shinytest2\} R  info      11:09:58.87 Shiny app started
# \{shinytest2\} R  info      11:09:59.07 Setting inputs: 'bins'
# \{chromote\}   JS websocket 11:09:59.08 recv \{"recalculating":\{"name":"distPlot",|truncated
# \{chromote\}   JS websocket 11:09:59.08 recv \{"busy":"idle"\}
# \{chromote\}   JS info      11:09:59.08 shinytest2; shiny:idle
# \{chromote\}   JS websocket 11:09:59.08 recv \{"errors":\{\},"values":\{"distPlot":\{|truncated
# \{chromote\}   JS info      11:09:59.08 shinytest2; shiny:value distPlot
# \{chromote\}   JS info      11:09:59.08 shinytest2; inputQueue: adding bins
# \{chromote\}   JS info      11:09:59.09 shinytest2; inputQueue: flushing bins
# \{chromote\}   JS websocket 11:09:59.10 send \{"method":"update","data":\{"bins":20\}\}
# \{chromote\}   JS websocket 11:09:59.11 recv \{"progress":\{"type":"binding",|truncated
# \{chromote\}   JS websocket 11:09:59.11 recv \{"busy":"busy"\}
# \{chromote\}   JS info      11:09:59.11 shinytest2; shiny:busy
# \{chromote\}   JS websocket 11:09:59.12 recv \{"custom":\{"showcase-src":\{"srcref":|truncated
# \{chromote\}   JS websocket 11:09:59.14 recv \{"recalculating":\{"name":"distPlot",|truncated
# \{chromote\}   JS websocket 11:09:59.18 recv \{"recalculating":\{"name":"distPlot",|truncated
# \{chromote\}   JS websocket 11:09:59.19 recv \{"busy":"idle"\}
# \{chromote\}   JS info      11:09:59.19 shinytest2; shiny:idle
# \{chromote\}   JS websocket 11:09:59.21 recv \{"errors":\{\},"values":\{"distPlot":\{|truncated
# \{chromote\}   JS info      11:09:59.21 shinytest2; shiny:value distPlot
# \{shinytest2\} R  info      11:09:59.21 Finished setting inputs. Timedout: FALSE
# \{shinytest2\} R  info      11:09:59.21 Getting all values
# \{shiny\}      R  error     ----------- Loading required package: shiny
# \{shiny\}      R  error     ----------- Running application in test mode.
# \{shiny\}      R  error     -----------
# \{shiny\}      R  error     ----------- Listening on http://127.0.0.1:1505
# \{shiny\}      R  error     ----------- SEND \{"config":\{"workerId":"","sessionId":|truncated
# \{shiny\}      R  error     ----------- RECV \{"method":"init","data":\{"bins":30,|truncated
# \{shiny\}      R  error     ----------- SEND \{"custom":\{"showcase-src":\{"srcref"|truncated
# \{shiny\}      R  error     ----------- SEND \{"busy":"busy"\}
# \{shiny\}      R  error     ----------- SEND \{"custom":\{"showcase-src":\{"srcref"|truncated
# \{shiny\}      R  error     ----------- SEND \{"recalculating":\{"name":"distPlot",|truncated
# \{shiny\}      R  error     ----------- SEND \{"recalculating":\{"name":"distPlot",|truncated
# \{shiny\}      R  error     ----------- SEND \{"busy":"idle"\}
# \{shiny\}      R  error     ----------- SEND \{"errors":\{\},"values":\{"distPlot":\{|truncated
# \{shiny\}      R  error     ----------- RECV \{"method":"update","data":\{"bins":20\}\}
# \{shiny\}      R  error     ----------- SEND \{"progress":\{"type":"binding",|truncated
# \{shiny\}      R  error     ----------- SEND \{"busy":"busy"\}
# \{shiny\}      R  error     ----------- SEND \{"custom":\{"showcase-src":\{"srcref":|truncated
# \{shiny\}      R  error     ----------- SEND \{"recalculating":\{"name":"distPlot",|truncated
# \{shiny\}      R  error     ----------- SEND \{"recalculating":\{"name":"distPlot",|truncated
# \{shiny\}      R  error     ----------- SEND \{"busy":"idle"\}
# \{shiny\}      R  error     ----------- SEND \{"errors":\{\},"values":\{"distPlot":\{|truncated

}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{AppDriver$new()}}
\item \href{#method-view}{\code{AppDriver$view()}}
\item \href{#method-expect_text}{\code{AppDriver$expect_text()}}
\item \href{#method-get_text}{\code{AppDriver$get_text()}}
\item \href{#method-expect_html}{\code{AppDriver$expect_html()}}
\item \href{#method-get_html}{\code{AppDriver$get_html()}}
\item \href{#method-expect_js}{\code{AppDriver$expect_js()}}
\item \href{#method-expect_download}{\code{AppDriver$expect_download()}}
\item \href{#method-get_download}{\code{AppDriver$get_download()}}
\item \href{#method-get_value}{\code{AppDriver$get_value()}}
\item \href{#method-get_values}{\code{AppDriver$get_values()}}
\item \href{#method-expect_values}{\code{AppDriver$expect_values()}}
\item \href{#method-screenshot}{\code{AppDriver$screenshot()}}
\item \href{#method-expect_screenshot}{\code{AppDriver$expect_screenshot()}}
\item \href{#method-set_inputs}{\code{AppDriver$set_inputs()}}
\item \href{#method-click}{\code{AppDriver$click()}}
\item \href{#method-upload_file}{\code{AppDriver$upload_file()}}
\item \href{#method-wait_for_js}{\code{AppDriver$wait_for_js()}}
\item \href{#method-wait_for_idle}{\code{AppDriver$wait_for_idle()}}
\item \href{#method-wait_for_value}{\code{AppDriver$wait_for_value()}}
\item \href{#method-execute_js}{\code{AppDriver$execute_js()}}
\item \href{#method-expect_unique_names}{\code{AppDriver$expect_unique_names()}}
\item \href{#method-get_dir}{\code{AppDriver$get_dir()}}
\item \href{#method-get_url}{\code{AppDriver$get_url()}}
\item \href{#method-get_window_size}{\code{AppDriver$get_window_size()}}
\item \href{#method-set_window_size}{\code{AppDriver$set_window_size()}}
\item \href{#method-get_chromote_session}{\code{AppDriver$get_chromote_session()}}
\item \href{#method-get_variant}{\code{AppDriver$get_variant()}}
\item \href{#method-get_log}{\code{AppDriver$get_log()}}
\item \href{#method-log_message}{\code{AppDriver$log_message()}}
\item \href{#method-stop}{\code{AppDriver$stop()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize the AppDriver
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$new(
  app_dir = testthat::test_path("../../"),
  ...,
  name = NULL,
  variant = missing_arg(),
  seed = NULL,
  load_timeout = NULL,
  screenshot_args = missing_arg(),
  expect_values_screenshot_args = TRUE,
  check_names = TRUE,
  view = missing_arg(),
  height = NULL,
  width = NULL,
  clean_logs = TRUE,
  shiny_args = list(),
  render_args = NULL,
  options = list()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{app_dir}}{Directory containing your Shiny application or a runtime
Shiny R Markdown document.}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{name}}{Prefix name to use when saving testthat snapshot files}

\item{\code{variant}}{If not-\code{NULL}, results will be saved in
_snaps/{variant}/{test.md}\verb{, so }variant` must be a single
string of alphanumeric characters suitable for use as a
directory name.

You can variants to deal with cases where the snapshot output
varies and you want to capture and test the variations.
Common use cases include variations for operating system, R
version, or version of key dependency. For example usage,
see \code{\link[=platform_variant]{platform_variant()}}.}

\item{\code{seed}}{An optional random seed to use before starting the application.
For apps that use R's random number generator, this can make their
behavior repeatable.}

\item{\code{load_timeout}}{How long to wait for the app to load, in ms.
This includes the time to start R. Defaults to 10s when running
locally and 20s when running on CI.}

\item{\code{screenshot_args}}{Default set of arguments to pass in to
\code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}'s \verb{$screenshot()} method when taking
screnshots within \verb{$expect_screenshot()}. To disable screenshots by
default, set to \code{FALSE}.}

\item{\code{expect_values_screenshot_args}}{The value for \code{screenshot_args} when
producing a debug screenshot for \verb{$expect_values()}.}

\item{\code{check_names}}{Check if widget names are unique once the application
initially loads? If duplicate names are found, only a warning will be
displayed.}

\item{\code{view}}{Opens the Chromote Session in an interactive browser tab once
initialization. Defaults to \code{FALSE}.}

\item{\code{height, width}}{Window size to use when opening the Chromote Session.
These values will only be used if both \code{height} and \code{width} are not
\code{NULL}.}

\item{\code{clean_logs}}{Whether to remove the stdout and stderr logs when the
Shiny process object is garbage collected.}

\item{\code{shiny_args}}{A list of options to pass to \code{\link[shiny:runApp]{shiny::runApp()}}. Ex:
\code{list(port = 8080)}.}

\item{\code{render_args}}{Passed to \code{rmarkdown::run(render_args=)} for
interactive \code{.Rmd}s. Ex: `list(quiet = TRUE)}

\item{\code{options}}{A list of \code{\link[base:options]{base::options()}} to set in the driver's child
process. See \code{\link[shiny:shinyOptions]{shiny::shinyOptions()}} for inspiration. If \code{shiny.trace = TRUE},
then all WebSocket traffic will be captured by \code{chromote} and logged.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-view"></a>}}
\if{latex}{\out{\hypertarget{method-view}{}}}
\subsection{Method \code{view()}}{
Calls \verb{$view()} on the Chromote Session object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$view()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_text"></a>}}
\if{latex}{\out{\hypertarget{method-expect_text}{}}}
\subsection{Method \code{expect_text()}}{
Expect snapshot of UI text

\verb{$expect_text()} will extract the text value of all matching elements via \code{TAG.textContent} and store them in a snapshot file.
This method is more robust to internal package change as only the text values will be maintained.

When possible, use \verb{$expect_text()} over \verb{$expect_html()} to allow package authors room to alter their HTML structures.
The resulting array of \code{TAG.textContent} values found will be stored in a snapshot file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_text(selector, ..., cran = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{selector}}{A DOM CSS selector to be passed into \code{document.querySelectorAll()}}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_text"></a>}}
\if{latex}{\out{\hypertarget{method-get_text}{}}}
\subsection{Method \code{get_text()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_text(selector)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{selector}}{A DOM CSS selector to be passed into \code{document.querySelectorAll()}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_html"></a>}}
\if{latex}{\out{\hypertarget{method-expect_html}{}}}
\subsection{Method \code{expect_html()}}{
Expect snapshot of UI HTML

\verb{$expect_html()} will extract the full DOM structures of each matching element and store them in a snapshot file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_html(selector, ..., outer_html = TRUE, cran = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{selector}}{A DOM selector to be passed into \code{document.querySelectorAll()}}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{outer_html}}{If \code{TRUE}, the full DOM structure will be returned (\code{TAG.outerHTML}).
If \code{FALSE}, the full DOM structure of the child elements will be returned (\code{TAG.innerHTML}).}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_html"></a>}}
\if{latex}{\out{\hypertarget{method-get_html}{}}}
\subsection{Method \code{get_html()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_html(selector, ..., outer_html = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{selector}}{A DOM selector to be passed into \code{document.querySelectorAll()}}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{outer_html}}{If \code{TRUE}, the full DOM structure will be returned (\code{TAG.outerHTML}).
If \code{FALSE}, the full DOM structure of the child elements will be returned (\code{TAG.innerHTML}).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_js"></a>}}
\if{latex}{\out{\hypertarget{method-expect_js}{}}}
\subsection{Method \code{expect_js()}}{
Expect snapshot of JS script output

This is a building block function that should be called by other functions.
For example, \verb{$expect_text()} and \verb{$expect_html()} are thin wrappers around this function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_js(
  script = missing_arg(),
  ...,
  arguments = list(),
  file = missing_arg(),
  timeout = 15 * 1000,
  pre_snapshot = NULL,
  cran = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{script}}{A string containing the JS script to be executed.}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{arguments}}{A list of unnamed arguments to send to the script.}

\item{\code{file}}{A file containing JavaScript code to be read and used as the \code{script}. Only one of \code{script} or \code{file} can be specified.}

\item{\code{timeout}}{Amount of time to wait before giving up (milliseconds).}

\item{\code{pre_snapshot}}{A function to be called on the result of the script before taking the snapshot.
\verb{$expect_html()} and \verb{$expect_text()} both use \code{\link[=unlist]{unlist()}}.}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_download"></a>}}
\if{latex}{\out{\hypertarget{method-expect_download}{}}}
\subsection{Method \code{expect_download()}}{
Expect a download file action.

Given a \code{\link[shiny:downloadButton]{shiny::downloadButton()}}/\code{\link[shiny:downloadButton]{shiny::downloadLink()}} \code{id}, the corresponding
file will be downloaded and saved as a snapshot file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_download(id, ..., name = NULL, cran = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{Output id of \code{\link[shiny:downloadButton]{shiny::downloadButton()}}/\code{\link[shiny:downloadButton]{shiny::downloadLink()}}}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{name}}{File name to save file to. The default, \code{NULL},
generates an ascending sequence of names: \verb{001.download},
\verb{002.download}, etc.}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_download"></a>}}
\if{latex}{\out{\hypertarget{method-get_download}{}}}
\subsection{Method \code{get_download()}}{
Retrieve download from a download file action.

Given a \code{\link[shiny:downloadButton]{shiny::downloadButton()}}/\code{\link[shiny:downloadButton]{shiny::downloadLink()}} \code{id}, the corresponding
file will be downloaded and saved as a file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_download(id, filename = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{Output id of \code{\link[shiny:downloadButton]{shiny::downloadButton()}}/\code{\link[shiny:downloadButton]{shiny::downloadLink()}}}

\item{\code{filename}}{File path to save the downloaded file to. If \code{NULL}, then a temp file ending in \code{.download} will be used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_value"></a>}}
\if{latex}{\out{\hypertarget{method-get_value}{}}}
\subsection{Method \code{get_value()}}{
Returns a named list of all inputs, outputs, and export values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_value(
  ...,
  input = missing_arg(),
  output = missing_arg(),
  export = missing_arg(),
  hash_images = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{input, output, export}}{One of these variable should contain a single string value. If more than one value is specified or no values are specified, an error will be thrown.}

\item{\code{hash_images}}{If \code{TRUE}, images will be hashed before being returned. Otherwise, all images will return their full data64 encoded value.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_values"></a>}}
\if{latex}{\out{\hypertarget{method-get_values}{}}}
\subsection{Method \code{get_values()}}{
Returns a named list of all inputs, outputs, and export values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_values(
  ...,
  input = missing_arg(),
  output = missing_arg(),
  export = missing_arg(),
  hash_images = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{input, output, export}}{Either \code{TRUE} to return all
input/output/exported values, or a character vector of specific
controls.}

\item{\code{hash_images}}{If \code{TRUE}, images will be hashed before being returned. Otherwise, all images will return their full data64 encoded value.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_values"></a>}}
\if{latex}{\out{\hypertarget{method-expect_values}{}}}
\subsection{Method \code{expect_values()}}{
Take and appshot of the Shiny application

Appshot: Shiny \strong{App}lication Snap\strong{shot}

An appshot currently consists of two snapshot files:
\enumerate{
\item A screenshot of the Shiny application using the \verb{$screenshot()} function of the \code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}
\item A JSON snapshot of all Shiny component values
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_values(
  ...,
  input = missing_arg(),
  output = missing_arg(),
  export = missing_arg(),
  screenshot_args = missing_arg(),
  name = NULL,
  cran = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{input, output, export}}{Depending on which parameters are supplied, different return values can occur:
* If \code{input}, \code{output}, and \code{export} are missing, then all values are included in the snapshot.
* If at least one \code{input}, \code{output}, or \code{export} is specified, then only those values are included in the snapshot.
The values supplied can be:
* A character vector of specific names to only include in the snapshot.
* \code{TRUE}, then all values of that type are included in the snapshot.
* Anything else will result in the parameter being ignored.}

\item{\code{screenshot_args}}{This value is passed along to \verb{$expect_screenshot()} where the resulting expectation is ignored. If missing, the default value will be \verb{$initialize(expect_values_screenshot_args=)}.

The final value can either be:
\itemize{
\item \code{TRUE}: A screenshot of the whole page will be taken with no delay
\item \code{FALSE}: No screenshot will be taken
\item A named list of arguments: Arguments passed directly to \code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}'s
\verb{$screenshot()} method. The selector and delay will default to \code{"html"} and \code{0} respectively.
Take a screenshot of the Shiny application
}}

\item{\code{name}}{The file name to be used for the snapshot. The file extension will be ignored. By default, this uses the name supplied to \code{app} on initialization with a counter.}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-screenshot"></a>}}
\if{latex}{\out{\hypertarget{method-screenshot}{}}}
\subsection{Method \code{screenshot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$screenshot(
  file = NULL,
  ...,
  screenshot_args = missing_arg(),
  delay = missing_arg(),
  selector = missing_arg()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{file}}{If \code{NULL}, then the image will be displayed to the current Graphics Device. If a file path, then the screenshot will be saved to that file.
Expect a screenshot of the Shiny application}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{screenshot_args}}{This named list of arguments is passed along to \code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}'s \verb{$screenshot()} method.
If missing, the value will default to \verb{$initialize(screenshot_args=)}.

If the value is:
\itemize{
\item \code{TRUE}: A screenshot of the whole page will be taken with no delay
\item A named list of arguments: Arguments passed directly to \code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}'s
\verb{$screenshot()} method. The selector and delay will default to \code{"html"} and \code{0} respectively.
}

If a \code{FALSE} value is provided, the parameter will be ignored and a screenshot will be taken with default behavior.}

\item{\code{delay}}{The number of milliseconds to wait before taking the screenshot. This value can either be supplied as \code{delay} or \code{screenshot_args}'s delay slot. The \code{delay} parameter will have preference.}

\item{\code{selector}}{The selector is a CSS selector that will be used to select a portion of the page to be captured. This value can either be supplied as \code{selector} or \code{screenshot_args}'s selector slot. The \code{selector} parameter will have preference.
The default value is to take a picture of the whole page.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_screenshot"></a>}}
\if{latex}{\out{\hypertarget{method-expect_screenshot}{}}}
\subsection{Method \code{expect_screenshot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_screenshot(
  ...,
  screenshot_args = missing_arg(),
  delay = missing_arg(),
  selector = missing_arg(),
  name = NULL,
  cran = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{screenshot_args}}{This named list of arguments is passed along to
\code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}'s \verb{$screenshot()} method. If missing, the
value will default to \verb{$initialize(screenshot_args=)}.

If the value is:
\itemize{
\item \code{TRUE}: A screenshot of the whole page will be taken with no delay
\item A named list of arguments: Arguments passed directly to \code{\link[chromote:ChromoteSession]{chromote::ChromoteSession}}'s
\verb{$screenshot()} method. The selector and delay will default to \code{"html"} and \code{0} respectively.
}

If a \code{FALSE} value is provided, the parameter will be ignored and a
screenshot will be taken with default behavior.}

\item{\code{delay}}{The number of milliseconds to wait before taking the
screenshot. This value can either be supplied as \code{delay} or
\code{screenshot_args}'s delay slot. The \code{delay} parameter will have
preference.}

\item{\code{selector}}{The selector is a CSS selector that will be used to
select a portion of the page to be captured. This value can either be
supplied as \code{selector} or \code{screenshot_args}'s selector slot. The
\code{selector} parameter will have preference. The default value is to take
a picture of the whole page.}

\item{\code{name}}{The file name to be used for the snapshot. The file extension will overwritten to \code{.png}. By default, this uses the name supplied to \code{app} on initialization with a counter.}

\item{\code{cran}}{Should these expectations be verified on CRAN? By default,
they are not, because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_inputs"></a>}}
\if{latex}{\out{\hypertarget{method-set_inputs}{}}}
\subsection{Method \code{set_inputs()}}{
Set input values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$set_inputs(
  ...,
  wait_ = TRUE,
  timeout_ = 3 * 1000,
  allow_no_input_binding_ = FALSE,
  priority_ = c("input", "event")
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Name-value pairs, \verb{component_name_1 = value_1, component_name_2 = value_2} etc.
Input with name \code{component_name_1} will be assigned value \code{value_1}.}

\item{\code{wait_}}{Wait until all reactive updates have completed?}

\item{\code{timeout_}}{Amount of time to wait before giving up (milliseconds).}

\item{\code{allow_no_input_binding_}}{When setting the value of an input, allow
it to set the value of an input even if that input does not have
an input binding.}

\item{\code{priority_}}{Sets the event priority. For expert use only: see
\url{https://shiny.rstudio.com/articles/communicating-with-js.html#values-vs-events} for details.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns updated values, invisibly.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-click"></a>}}
\if{latex}{\out{\hypertarget{method-click}{}}}
\subsection{Method \code{click()}}{
Find a Shiny input/output value or DOM CSS selector and click it using the DOM method \code{TAG.click()}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$click(
  input = missing_arg(),
  output = missing_arg(),
  selector = missing_arg(),
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{input, output, selector}}{A name of an Shiny input/output value or a DOM CSS selector. Only one of these may be used.}

\item{\code{...}}{If \code{input} is used, all extra arguments are passed to \verb{$set_inputs(!!input := "click", ...)}. By default, this means that the AppDriver will wait until an output has been updated within the specified \code{timeout_}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-upload_file"></a>}}
\if{latex}{\out{\hypertarget{method-upload_file}{}}}
\subsection{Method \code{upload_file()}}{
Uploads a file to a file input.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$upload_file(..., wait_ = TRUE, timeout_ = 3 * 1000)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Name-path pair, e.g. \code{component_name = file_path}. The file located at
\code{file_path} will be uploaded to file input with name \code{component_name}.}

\item{\code{wait_}}{Wait until all reactive updates have completed?}

\item{\code{timeout_}}{Amount of time to wait before giving up (milliseconds).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-wait_for_js"></a>}}
\if{latex}{\out{\hypertarget{method-wait_for_js}{}}}
\subsection{Method \code{wait_for_js()}}{
Wait for a JavaScript expression to be true

Waits until a JavaScript \code{expr}ession evaluates to \code{true} or the
\code{timeout} is exceeded.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$wait_for_js(script, timeout = 30 * 1000, interval = 100)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{script}}{A string containing JavaScript code. This code must eventually return a \code{true}thy value or a \code{timeout} error will be thrown.}

\item{\code{timeout}}{How long the script has to return a \code{true}thy value, in ms.}

\item{\code{interval}}{How often to check for the condition, in ms.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{invisible(self)} if expression evaluates to \code{true} without error within the timeout.
Otherwise an error will be thrown
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-wait_for_idle"></a>}}
\if{latex}{\out{\hypertarget{method-wait_for_idle}{}}}
\subsection{Method \code{wait_for_idle()}}{
Wait for Shiny to not be busy (idle) for a set amount of time

Waits until Shiny has not been busy for a set duration of time, i.e. no reactivity is updating or has occured.
This is useful, for example, when waiting for your application to initialize or
if you've resized the window with \verb{$set_window_size()} and want to make sure all
plot redrawing is complete before take a screenshot.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$wait_for_idle(duration = 500, timeout = 30 * 1000)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{duration}}{How long Shiny must be idle (in ms) before unblocking the R session.}

\item{\code{timeout}}{How often to check for the condition, in ms.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{invisible(self)} if Shiny stablizes within the timeout. Otherwise an error will be thrown
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-wait_for_value"></a>}}
\if{latex}{\out{\hypertarget{method-wait_for_value}{}}}
\subsection{Method \code{wait_for_value()}}{
Wait for a new Shiny value

Waits until \code{input}, \code{output}, or \code{export}ed shiny value is not one of
\code{ignore}d values, or the timeout is reached.

Only a single \code{input}, \code{output}, or \code{export} value may be used.

This function can be useful in helping determine if an application
has finished processing a complex reactive situation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$wait_for_value(
  ...,
  input = missing_arg(),
  output = missing_arg(),
  export = missing_arg(),
  ignore = list(NULL, ""),
  timeout = 15 * 1000,
  interval = 400
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{input, output, export}}{A name of an input, output, or export value. Only one of these parameters may be used.}

\item{\code{ignore}}{List of possible values to ignore when checking for
updates.}

\item{\code{timeout}}{How long we can wait (in ms) before throwing an error.}

\item{\code{interval}}{How often to check for the condition, in ms.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Newly found value
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-execute_js"></a>}}
\if{latex}{\out{\hypertarget{method-execute_js}{}}}
\subsection{Method \code{execute_js()}}{
Execute JavaScript code in the browser.

This function will block the local R session until the code has finished executing its \emph{tick} in the browser.
If a \code{Promise} is returned from the script, \verb{$execute_js()} will wait for the promise to resolve.
To have JavaScript code execute asynchronously, wrap the code in a Promise object and have the script return an atomic value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$execute_js(
  script = missing_arg(),
  ...,
  arguments = list(),
  file = missing_arg(),
  timeout = 15 * 1000
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{script}}{JS to execute. If a JS Promise is returned, the R session will block until the promise has been resolved and return the value.}

\item{\code{...}}{Must be empty. Allows for parameter expansion.}

\item{\code{arguments}}{A list of unnamed arguments to send to the script.}

\item{\code{file}}{A (local) file containing JavaScript code to be read and used as the \code{script}. Only one of \code{script} or \code{file} can be specified.}

\item{\code{timeout}}{Amount of time to wait before giving up (milliseconds).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Result of the \code{script} (or \code{file} contents)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expect_unique_names"></a>}}
\if{latex}{\out{\hypertarget{method-expect_unique_names}{}}}
\subsection{Method \code{expect_unique_names()}}{
Expect unique input and output names.

If the HTML has duplicate input or output elements with matching \code{id} values, this function will
throw an error. It is similar to \code{AppDriver$new(check_names = TRUE)}, but
asserts that no warnings are displayed.

This method will not throw if a single input and a single output have the same name.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$expect_unique_names()}\if{html}{\out{</div>}}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{example_app <- system.file("tests/testthat/apps/init-input/", package = "shinytest2")
# Initial checking for unique names (default behavior)
\dontrun{app <- AppDriver$new(example_app, check_names = TRUE)}
# Manually assert that all names are unique
\dontrun{app <- AppDriver$new(example_app, check_names = FALSE)
app$expect_unique_names()}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_dir"></a>}}
\if{latex}{\out{\hypertarget{method-get_dir}{}}}
\subsection{Method \code{get_dir()}}{
Retrieve the Shiny app path
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_dir()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
If it's a .Rmd file, it will return the full .Rmd path, otherwise it will return the directory containing the file.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_url"></a>}}
\if{latex}{\out{\hypertarget{method-get_url}{}}}
\subsection{Method \code{get_url()}}{
Retrieve the Shiny app URL
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_url()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
URL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_window_size"></a>}}
\if{latex}{\out{\hypertarget{method-get_window_size}{}}}
\subsection{Method \code{get_window_size()}}{
Get current size of the browser window, as list of integer scalars
named \code{width} and \code{height}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_window_size()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_window_size"></a>}}
\if{latex}{\out{\hypertarget{method-set_window_size}{}}}
\subsection{Method \code{set_window_size()}}{
Sets size of the browser window.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$set_window_size(width, height, wait = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{width, height}}{Height and width of browser, in pixels.}

\item{\code{wait}}{If \code{TRUE}, \verb{$wait_for_idle()} will be called after setting the window size.
This will allow for any width specific items (such as plots) to be rerendered.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_chromote_session"></a>}}
\if{latex}{\out{\hypertarget{method-get_chromote_session}{}}}
\subsection{Method \code{get_chromote_session()}}{
Chromote Session object from the \pkg{chromote} package.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_chromote_session()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_variant"></a>}}
\if{latex}{\out{\hypertarget{method-get_variant}{}}}
\subsection{Method \code{get_variant()}}{
Get the variant supplied at initialization
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_variant()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_log"></a>}}
\if{latex}{\out{\hypertarget{method-get_log}{}}}
\subsection{Method \code{get_log()}}{
Query one or more of the debug logs.
There are a few standard debug types that may be used:
\itemize{
\item \code{"shiny_console"}: Displays the console messages from the Shiny server when \verb{$get_log()} is called.
\item \code{"browser"}: Displays the browser console messages when \verb{$get_log()} is called.
\item \code{"shinytest2"}: Displays the messages saved by the \code{window.shinytest2} object in the browser when \verb{$get_log()} is called.
\item \code{"ws_messages"}: Saves all messages sent by Shiny to the
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$get_log()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A data.frame with the following columns:
\itemize{
\item \code{workerid}: The shiny worker ID found within the browser
\item \code{timestamp}: POSIXct timestamp of the message
\item \code{location}: The location of the message was found. One of three values:
\itemize{
\item \code{shinytest2}: Occurs when \verb{$log_message()} is called
\item \code{shiny}: Stdin and stdout messages from the Shiny server. Note \code{message()} output is sent to stdout.
\item \code{chromote}: Captured by the \pkg{chromote} event handlers. See
\href{https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/#event-consoleAPICalled}{console API},
\href{https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/#event-exceptionThrown}{exception thrown},
\href{https://chromedevtools.github.io/devtools-protocol/1-3/Network/#event-webSocketFrameSent}{websocket sent}, and
\href{https://chromedevtools.github.io/devtools-protocol/1-3/Network/#event-webSocketFrameReceived}{websocket received}
for more details
}
\item \code{level}:
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{

app <- AppDriver$new(system.file("examples/01_hello", package = "shiny"))
app$get_log()
# \{shinytest2\} R  info  11:15:20.11 Start AppDriver initialization
# \{shinytest2\} R  info  11:15:20.11 Starting Shiny app
# \{shinytest2\} R  info  11:15:20.99 Creating new chromote session
# \{shinytest2\} R  info  11:15:21.14 Navigating to Shiny app
# \{shinytest2\} R  info  11:15:21.27 Injecting shiny-tracer.js
# \{chromote\}   JS info  11:15:21.28 shinytest2; jQuery not found
# \{chromote\}   JS info  11:15:21.28 shinytest2; Loaded
# \{shinytest2\} R  info  11:15:21.28 Waiting until Shiny app starts
# \{chromote\}   JS info  11:15:21.35 shinytest2; jQuery found
# \{chromote\}   JS info  11:15:21.35 shinytest2; Waiting for shiny session to connect
# \{chromote\}   JS info  11:15:21.57 shinytest2; Connected
# \{chromote\}   JS info  11:15:21.57 shinytest2; Ready
# \{chromote\}   JS info  11:15:21.65 shinytest2; shiny:busy
# \{shinytest2\} R  info  11:15:21.65 Shiny app started
# \{chromote\}   JS info  11:15:21.88 shinytest2; shiny:idle
# \{chromote\}   JS info  11:15:21.88 shinytest2; shiny:value distPlot
# \{shiny\}      R  error ----------- Loading required package: shiny
# \{shiny\}      R  error ----------- Running application in test mode.
# \{shiny\}      R  error -----------
# \{shiny\}      R  error ----------- Listening on http://127.0.0.1:42558


# To capture all websocket traffic, set `options = list(shiny.trace = TRUE)`
app <- AppDriver$new(
  system.file("examples/01_hello", package = "shiny"),
  options = list(shiny.trace = TRUE)
)
app$get_log() # (long output lines have been truncated)
# \{shinytest2\} R  info      11:09:57.43 Start AppDriver initialization
# \{shinytest2\} R  info      11:09:57.43 Starting Shiny app
# \{shinytest2\} R  info      11:09:58.27 Creating new chromote session
# \{shinytest2\} R  info      11:09:58.40 Navigating to Shiny app
# \{shinytest2\} R  info      11:09:58.53 Injecting shiny-tracer.js
# \{chromote\}   JS info      11:09:58.53 shinytest2; jQuery not found
# \{chromote\}   JS info      11:09:58.53 shinytest2; Loaded
# \{shinytest2\} R  info      11:09:58.54 Waiting until Shiny app starts
# \{chromote\}   JS info      11:09:58.61 shinytest2; jQuery found
# \{chromote\}   JS info      11:09:58.61 shinytest2; Waiting for shiny session to connect
# \{chromote\}   JS websocket 11:09:58.73 send \{"method":"init","data":\{"bins":30,|truncated
# \{chromote\}   JS websocket 11:09:58.78 recv \{"config":\{"workerId":"","sessionId":|truncated
# \{chromote\}   JS info      11:09:58.78 shinytest2; Connected
# \{chromote\}   JS info      11:09:58.78 shinytest2; Ready
# \{chromote\}   JS websocket 11:09:58.85 recv \{"custom":\{"showcase-src":\{"srcref":|truncated
# \{chromote\}   JS websocket 11:09:58.85 recv \{"busy":"busy"\}
# \{chromote\}   JS info      11:09:58.85 shinytest2; shiny:busy
# \{chromote\}   JS websocket 11:09:58.86 recv \{"custom":\{"showcase-src":\{"srcref":|truncated
# \{chromote\}   JS websocket 11:09:58.86 recv \{"recalculating":\{"name":"distPlot",|truncated
# \{shinytest2\} R  info      11:09:58.87 Shiny app started
# \{shinytest2\} R  info      11:09:59.07 Setting inputs: 'bins'
# \{chromote\}   JS websocket 11:09:59.08 recv \{"recalculating":\{"name":"distPlot",|truncated
# \{chromote\}   JS websocket 11:09:59.08 recv \{"busy":"idle"\}
# \{chromote\}   JS info      11:09:59.08 shinytest2; shiny:idle
# \{chromote\}   JS websocket 11:09:59.08 recv \{"errors":\{\},"values":\{"distPlot":\{|truncated
# \{chromote\}   JS info      11:09:59.08 shinytest2; shiny:value distPlot
# \{chromote\}   JS info      11:09:59.08 shinytest2; inputQueue: adding bins
# \{chromote\}   JS info      11:09:59.09 shinytest2; inputQueue: flushing bins
# \{chromote\}   JS websocket 11:09:59.10 send \{"method":"update","data":\{"bins":20\}\}
# \{chromote\}   JS websocket 11:09:59.11 recv \{"progress":\{"type":"binding",|truncated
# \{chromote\}   JS websocket 11:09:59.11 recv \{"busy":"busy"\}
# \{chromote\}   JS info      11:09:59.11 shinytest2; shiny:busy
# \{chromote\}   JS websocket 11:09:59.12 recv \{"custom":\{"showcase-src":\{"srcref":|truncated
# \{chromote\}   JS websocket 11:09:59.14 recv \{"recalculating":\{"name":"distPlot",|truncated
# \{chromote\}   JS websocket 11:09:59.18 recv \{"recalculating":\{"name":"distPlot",|truncated
# \{chromote\}   JS websocket 11:09:59.19 recv \{"busy":"idle"\}
# \{chromote\}   JS info      11:09:59.19 shinytest2; shiny:idle
# \{chromote\}   JS websocket 11:09:59.21 recv \{"errors":\{\},"values":\{"distPlot":\{|truncated
# \{chromote\}   JS info      11:09:59.21 shinytest2; shiny:value distPlot
# \{shinytest2\} R  info      11:09:59.21 Finished setting inputs. Timedout: FALSE
# \{shinytest2\} R  info      11:09:59.21 Getting all values
# \{shiny\}      R  error     ----------- Loading required package: shiny
# \{shiny\}      R  error     ----------- Running application in test mode.
# \{shiny\}      R  error     -----------
# \{shiny\}      R  error     ----------- Listening on http://127.0.0.1:1505
# \{shiny\}      R  error     ----------- SEND \{"config":\{"workerId":"","sessionId":|truncated
# \{shiny\}      R  error     ----------- RECV \{"method":"init","data":\{"bins":30,|truncated
# \{shiny\}      R  error     ----------- SEND \{"custom":\{"showcase-src":\{"srcref"|truncated
# \{shiny\}      R  error     ----------- SEND \{"busy":"busy"\}
# \{shiny\}      R  error     ----------- SEND \{"custom":\{"showcase-src":\{"srcref"|truncated
# \{shiny\}      R  error     ----------- SEND \{"recalculating":\{"name":"distPlot",|truncated
# \{shiny\}      R  error     ----------- SEND \{"recalculating":\{"name":"distPlot",|truncated
# \{shiny\}      R  error     ----------- SEND \{"busy":"idle"\}
# \{shiny\}      R  error     ----------- SEND \{"errors":\{\},"values":\{"distPlot":\{|truncated
# \{shiny\}      R  error     ----------- RECV \{"method":"update","data":\{"bins":20\}\}
# \{shiny\}      R  error     ----------- SEND \{"progress":\{"type":"binding",|truncated
# \{shiny\}      R  error     ----------- SEND \{"busy":"busy"\}
# \{shiny\}      R  error     ----------- SEND \{"custom":\{"showcase-src":\{"srcref":|truncated
# \{shiny\}      R  error     ----------- SEND \{"recalculating":\{"name":"distPlot",|truncated
# \{shiny\}      R  error     ----------- SEND \{"recalculating":\{"name":"distPlot",|truncated
# \{shiny\}      R  error     ----------- SEND \{"busy":"idle"\}
# \{shiny\}      R  error     ----------- SEND \{"errors":\{\},"values":\{"distPlot":\{|truncated

}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-log_message"></a>}}
\if{latex}{\out{\hypertarget{method-log_message}{}}}
\subsection{Method \code{log_message()}}{
Add an message to log.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$log_message(message)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{message}}{Single message to store in log}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-stop"></a>}}
\if{latex}{\out{\hypertarget{method-stop}{}}}
\subsection{Method \code{stop()}}{
Stop the Shiny application
Stop the app, the terminate external R process that runs the app and
the Chromote Session instance.

To stop your shiny application and return a value from \verb{$stop()}, see \code{\link[shiny:stopApp]{shiny::stopApp()}}. This is useful in testing to return context information.

Typically, this is paired with a button that when clicked will call \code{shiny::stopApp(info)} to return \code{info} from the test app back to the main R session.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AppDriver$stop()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The result of the background process if the Shiny application has already been terminated.
}
}
}
