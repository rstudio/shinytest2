#' @include shiny-driver.R
# Directory for temp storing test artifacts
ShinyDriver2$set("private", "appshot_dir", NULL) # Temp folder to store snapshot outputs
ShinyDriver2$set("private", "should_take_screenshot", TRUE) # Whether to take screenshots for each snapshot
ShinyDriver2$set("private", "shiny_test_url", NULL) # URL for shiny's test API




sd2_appshot <- function(
  self, private,
  items = NULL,
  name = NULL,
  screenshot = NULL
  # TODO-barret: screenshot args?
) {
  if (!is.list(items) && !is.null(items)) {
    abort("'items' must be NULL or a list.")
  }

  snapshot_count <- private$appshot_count$increment()
  temp_save_dir  <- private$appshot_dir

  # Do not prefix with `self$name` as that is only necessary for the snapshot file name
  # At this point, the temp folder is already unique
  json_name <- fs::path_ext_set(name %||% sprintf("%03d", snapshot_count), "json")

  # The default is to take a screenshot when the `should_take_screenshot` option is
  # TRUE and the user does not specify specific items to snapshot.
  should_take_screenshot <- isTRUE(
    screenshot %||%
    (private$should_take_screenshot && is.null(items))
  )

  # Figure out which items to snapshot ----------------------------------------
  # By default, record all items.
  if (is.null(items)) {
    items <- list(input = TRUE, output = TRUE, export = TRUE)
  }

  extra_names <- setdiff(names(items), c("input", "output", "export"))
  if (length(extra_names) > 0) {
    abort(paste0(
      "'items' must be a list containing one or more items named",
      "'input', 'output' and 'export'. Each of these can be TRUE, FALSE, ",
      " or a character vector."
    ))
  }

  if (is.null(items$input))  items$input  <- FALSE
  if (is.null(items$output)) items$output <- FALSE
  if (is.null(items$export)) items$export <- FALSE

  # Take appshot -------------------------------------------------------------
  self$log_event("Taking appshot")
  self$log_event("Gathering input/output/export values")
  url <- sd2_get_shiny_test_url(self, private, items$input, items$output, items$export)
  req <- httr_get(url)

  # Convert to text, then replace base64-encoded images with hashes of them.
  content <- raw_to_utf8(req$content)
  # original_content <- content
  content <- hash_snapshot_image_data(content)
  content <- jsonlite::prettify(content, indent = 2)
  full_json_path <- fs::path(temp_save_dir, json_name)
  create_snapshot_dir(temp_save_dir, snapshot_count)
  write_utf8(content, full_json_path)

  full_screenshot_path <- NULL
  if (should_take_screenshot) {
    # Replace extension with .png
    full_screenshot_path <- fs::path(temp_save_dir, fs::path_ext_set(json_name, "png"))
    self$take_screenshot(full_screenshot_path)
  }

  list(
    screenshot_path = full_screenshot_path,
    json_path = full_json_path
    # json_original_content = original_content,
    # json_content = content
  )
  # TODO-prior;?; Invisibly return JSON content as a string
  # invisible(original_content)
}


# TODO-barret; Include these methods?
# ShinyDriver2$set("public", "expectSnapshotReactivity", function(
#   items = NULL,
#   name = NULL
# ) {
#   sd2_appshot(self, private, items = items, name = name, screenshot = FALSE)
# })
# ShinyDriver2$set("public", "expectSnapshotScreenshot", function(
#   name = NULL
# ) {
#   sd2_appshot(self, private, items = list(input = FALSE, output = FALSE, export = FALSE), name = name, screenshot = TRUE)
# })

#' @description
#' Snapshot a file download action. Generally, you should not call this
#' function yourself; it will be generated by `record_test()` as needed.
#' @param id Output id of [shiny::downloadButton()]/[shiny::downloadLink()]
#' @param name File name to save file to. The default, `NULL`,
#'   generates an ascending sequence of names: `001.download`,
#'   `002.download`, etc.
# #' @include shiny-driver.R
# ShinyDriver2$set("public", "snapshotDownload", function(id, name = NULL) {
sd2_appshot_download <- function(
  self, private,
  id, name = NULL
) {
  temp_save_dir <- private$appshot_dir
  snapshot_count <- private$appshot_count$increment()

  if (is.null(name)) {
    name <- sprintf("%03d.download", snapshot_count)
  }

  self$log_event("Downloading file")

  # Find the URL to download from (the href of the <a> tag)
  sub_url <- chromote_eval(self$get_chromote_session(), paste0("$('#", id, "').attr('href')"))$result$value
  if (identical(sub_url, "")) {
    stop("Download from '#", id, "' failed")
  }
  # Add the base location to the URL
  full_url <- paste0(private$shiny_url$get(), sub_url)
  req <- httr_get(full_url)

  download_path <- fs::path(temp_save_dir, name)
  create_snapshot_dir(temp_save_dir, snapshot_count)
  writeBin(req$content, download_path)

  list(
    download_path = download_path
  )
}


#' @description
#' Internal method. Generally, you should not call this function
#' yourself; it will be generated by `record_test()` as needed.
#' @param id Output id of [shiny::downloadButton()]/[shiny::downloadLink()]
#' @param name File name to save file to. The default, `NULL`,
#'   generates an ascending sequence of names: `001.download`,
#'   `002.download`, etc.
#' @include shiny-driver.R
ShinyDriver2$set("public", "expect_download", function(
  id,
  ...,
  name = NULL,
  cran = FALSE
) {
  testthat::expect_s3_class(self, "ShinyDriver2")
  ellipsis::check_dots_empty()

  snapshot_info <- sd2_appshot_download(self, private, id = id, name = name)

  # compare download_file
  testthat_expect_snapshot_file(
    private,
    snapshot_info$download_path,
    cran = cran,
    compare = testthat::compare_file_text
  )

  invisible(self)
})


#' Expect a downloadable file
#'
#' @param app A [ShinyDriver2] object.
#' @param id Output id of [shiny::downloadButton()]/[shiny::downloadLink()]
#' @param ... Must be empty. Allows for parameter expansion.
#' @param name File name to save file to. The default, `NULL`,
#'   generates an ascending sequence of names: `001.download`,
#'   `002.download`, etc.
#' @inheritParams testthat::expect_snapshot_file
#' @export
app_expect_download <- function(
  app,
  id,
  ...,
  name = NULL,
  cran = FALSE
) {
  app$expect_download(
    id = id,
    ...,
    name = name,
    cran = cran
  )
}


create_snapshot_dir <- function(dir, count) {
  if (count == 1) {
    if (fs::dir_exists(dir)) {
      unlink(dir, recursive = TRUE)
    }
    dir.create(dir, recursive = TRUE)
  }
}


sd2_get_shiny_test_url <- function(
  self, private,
  input = TRUE,
  output = TRUE,
  export = TRUE,
  format = "json"
) {
  q_string <- function(group, value) {
    if (isTRUE(value))
      paste0(group, "=1")
    else if (is.character(value))
      paste0(group, "=", paste(value, collapse = ","))
    else
      ""
  }
  paste(
    private$shiny_test_url,
    q_string("input", input),
    q_string("output", output),
    q_string("export", export),
    paste0("format=", format),
    "sortC=1",
    sep = "&"
  )
}


# Given a JSON string, find any strings that represent base64-encoded images
# and replace them with a hash of the value. The image is base64-decoded and
# then hashed with SHA1. The resulting hash value is the same as if the image
# were saved to a file on disk and then hashed.
hash_snapshot_image_data <- function(data) {

  # Search for base64-encoded image data. There are two named groups:
  # - data_url is the entire data URL, including the leading quote,
  #   "data:image/png;base64,", the base64-encoded data, and the trailing quote.
  # - img_data is just the base64-encoded data.
  image_offsets <- gregexpr(
    '\\n\\s*"[^"]*"\\s*:\\s*(?<data_url>"data:image/[^;]+;base64,(?<img_data>[^"]+)")',
    data,
    perl = TRUE
  )[[1]]

  # No image data found
  if (length(image_offsets) == 1 && image_offsets == -1) {
    return(data)
  }

  attr2 <- function(x, name) {
    attr(x, name, exact = TRUE)
  }

  # Image data indices
  image_start_idx <- as.integer(attr2(image_offsets, "capture.start")[, "img_data"])
  image_stop_idx <- image_start_idx +
    as.integer(attr2(image_offsets, "capture.length")[, "img_data"]) - 1

  # Text (non-image) data indices
  text_start_idx <- c(
    0,
    attr2(image_offsets, "capture.start")[, "data_url"] +
      attr2(image_offsets, "capture.length")[, "data_url"]
  )
  text_stop_idx <- c(
    attr(image_offsets, "capture.start")[, "data_url"] - 1,
    nchar(data)
  )

  # Get the strings representing image data, and all the other stuff
  image_data <- substring(data, image_start_idx, image_stop_idx)
  text_data  <- substring(data, text_start_idx,  text_stop_idx)

  # Hash the images
  image_hashes <- vapply(image_data, FUN.VALUE = "", function(dat) {
    tryCatch({
      image_data <- jsonlite::base64_dec(dat)
      rlang::hash(
        image_data
      )
    }, error = function(e) {
      "Error hashing image data"
    })
  })

  image_hashes <- paste0('"[image data sha1: ', image_hashes, ']"')

  # There's one fewer image hash than text elements. We need to add a blank
  # so that we can properly interleave them.
  image_hashes <- c(image_hashes, "")

  # Interleave the text data and the image hashes
  paste(
    c(rbind(text_data, image_hashes)),
    collapse = ""
  )
}
